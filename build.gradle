apply from: 'gradle/libraries.gradle'

apply plugin: 'com.github.ben-manes.versions'

buildscript {

    // I need build script classpath for foreign plugins
    repositories {
        maven {
            url artifactoryUrl + '/plugins-release-virtual'
        }
    }

    dependencies {
        classpath 'com.github.ben-manes:gradle-versions-plugin:0.9'
        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:+'
    }
}

// http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html
if (JavaVersion.current().isJava8Compatible()) {
  allprojects {
    tasks.withType(Javadoc) {
      options.addStringOption('Xdoclint:none', '-quiet')
    }
  }
}

allprojects {
    apply plugin: 'com.jfrog.artifactory'
    apply plugin: 'idea'
    version = '0.13.10'
    version += '.jersey2' // remove once feature is done
    if (!project.hasProperty('isRelease')) {
         version += '-SNAPSHOT'
    }
    group = 'de.otto'
}

configurations {
    archives
}

artifactory {
    contextUrl = artifactoryUrl
    //The base Artifactory URL if not overridden by the publisher/resolver
    publish {
        repository {
            if (!project.hasProperty('isRelease')) {
                repoKey = 'maven-san-snapshots-local'
            } else {
                repoKey = 'maven-san-releases-local'
            }
            username = artifactoryUsername
            password = artifactoryPassword
        }
        defaults {
            // Reference to Gradle publications defined in the build script.
            // This is how we tell the Artifactory Plugin which artifacts should be
            // published to Artifactory.
            publishConfigs('archives')
            publishArtifacts = true
            // Publish generated POM files to Artifactory (true by default)
            publishPom = true
        }
    }
    resolve {
        repository {
            repoKey = 'libs-release-virtual'
        }
    }
}

artifactoryPublish.skip = true

idea {
  project {
    languageLevel = '1.7'
  }
}

task wrapper(type: Wrapper) {
  gradleVersion = '2.4'
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven'

    sourceCompatibility = 1.7
    targetCompatibility = 1.7

    test {
        useTestNG()
    }

    manifest {
        attributes 'provider': 'gradle'
    }

    configurations {
        archives
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        classifier = 'javadoc'
        from javadoc.destinationDir
    }

    artifactoryPublish {
        dependsOn sourcesJar, javadocJar
    }

    artifacts {
        archives sourcesJar
        archives javadocJar
    }

    ext.cobSerFile="${project.buildDir}/cobertura.ser"
    ext.classesDir="${sourceSets.main.output.classesDir}"
    ext.copyOfClassesDir="${classesDir}-not-instrumented"

    task cobertura (type: Test) {

        jvmArgs '-XX:-UseSplitVerifier'

        useTestNG()
        systemProperties ["net.sourceforge.cobertura.datafile"] = cobSerFile

        doFirst {
            if (new File(classesDir).exists()) {
                logger.quiet "instrumenting classes for cobertura"
                ant {
                    // delete data file for cobertura, otherwise coverage would be added
                    delete(file:cobSerFile, failonerror:false)
                    // delete copy of original classes
                    delete(dir: copyOfClassesDir, failonerror:false)
                    // import cobertura task, so it is available in the script
                    taskdef(resource:'tasks.properties', classpath: configurations.testRuntime.asPath)
                    // create copy (backup) of original class files
                    copy(todir: copyOfClassesDir) {
                        fileset(dir: classesDir)
                    }
                    // instrument the relevant classes in-place
                    'cobertura-instrument'(datafile:cobSerFile) {
                        fileset(dir: classesDir,
                                //includes:"my/classes/**/*.class",
                                includes: "**/*.class",
                                excludes: "**/*Test.class")
                    }
                }
            }
        }

        doLast {
            logger.quiet "tidying up and generating cobertura report"
            if (new File(copyOfClassesDir).exists()) {
                // replace instrumented classes with backup copy again
                ant {
                    delete(file: classesDir)
                    move(file: copyOfClassesDir,
                            tofile: classesDir)
                }
                // create cobertura reports
                ant.'cobertura-report'(destdir:"${project.buildDir}/reports/cobertura",
                        format:'xml', srcdir:"src/main/java", datafile:cobSerFile)
                ant.'cobertura-report'(destdir:"${project.buildDir}/reports/cobertura",
                        format:'html', srcdir:"src/main/java", datafile:cobSerFile)
            }
        }
    }

}

